name: Build and Deploy to EKS

on:
  release:
    types: [created]

env:
  GITHUB_SHA: ${{ github.sha }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: my-python-app
  IMAGE_NAME: my-python-app
  EKS_CLUSTER: test
  DEPLOYMENT_NAME: my-python-app
  PORT: 5001

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and tag the Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$GITHUB_SHA .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$GITHUB_SHA $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$GITHUB_SHA
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Deploy to EKS
        run: |
          # Use your ECR image URI in the deployment manifest
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.GITHUB_SHA }}"
          
          # Create and apply the Kubernetes deployment manifest
          kubectl create deployment ${{ env.DEPLOYMENT_NAME }} --image=$IMAGE_URI --dry-run -o yaml > deployment.yaml
          kubectl apply -f deployment.yaml

          # Create and apply the Kubernetes LoadBalancer service manifest
          kubectl create service loadbalancer ${{ env.DEPLOYMENT_NAME }} --tcp=80:${{ env.PORT }} --dry-run -o yaml > service.yaml
          kubectl apply -f service.yaml
          
          # Check the status of the rollout and service
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }}
          kubectl get services -o wide
